// Code generated by tfsmcgen. DO NOT EDIT.
// This file was automatically generated from OpenAPI schema: Host
// Package provider implements the SMC Terraform provider resources and data sources.
package provider




import (
	"context"
	"encoding/json"
	"fmt"
	"strings"


	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/terraform-providers/terraform-provider-smc/internal/apijson"
	"github.com/terraform-providers/terraform-provider-smc/internal/sdk/request"
	"github.com/terraform-providers/terraform-provider-smc/internal/smc"
)


// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &HostResource{}
var _ resource.ResourceWithImportState = &HostResource{}
// var _ resource.ResourceWithModifyPlan = &HostResource{}

// Schema defines the schema for the Host resource.
func (r *HostResource) Schema(ctx context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
      Description: "This represents a Host, which is a Network Element that represents any single device that has an IP address. Any device connected to a TCP/IP network, including the Internet, with one or more IP addresses. Hosts are distinguishable from gateways or routers, in that they do not forward, or route, packets to other networks.",
      Attributes: GetHostSchemaAttributes(ctx),
    } // schema
    

}

// NewHostResource creates a new instance of the Host resource.
func NewHostResource() resource.Resource {
	return &HostResource{}
}

// HostResource defines the resource implementation.
type HostResource struct {
	client *smc.Client
	config *request.GenericCRUDConfig
}

// Metadata returns the resource type name.
func (r *HostResource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_host"
}

// Configure adds the provider configured client to the resource.
func (r *HostResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*smc.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *smc.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}

	// Ensure client is logged in
	if err := client.Login(ctx); err != nil {
		resp.Diagnostics.AddError(
			"SMC Login Failed",
			fmt.Sprintf("Unable to login to SMC: %s", err.Error()),
		)
		return
	}

	r.client = client
	r.config = &request.GenericCRUDConfig{
		BaseURL:                   client.URL,
		APIVersion:                client.APIVersion,
		Auth:                     client.Auth,
		ResourceType:             "host",
		GetJSONHeaders:           client.GetJSONHeaders,
		GetAuthHeaders:           client.GetAuthHeaders,
		GetJSONHeadersWithEtag:   client.GetJSONHeadersWithEtag,
		GetAuthHeadersWithEtag:   client.GetAuthHeadersWithEtag,
	}
}



// include 'resource_plan.j2'
// Create creates a new Host resource.
func (r *HostResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	if r.client == nil {
		resp.Diagnostics.AddError(
			"Unconfigured SMC Client",
			"Expected configured SMC client. Please report this issue to the provider developers.",
		)
		return
	}

	var data HostResourceModel

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Convert Terraform model to API model
	apiData, err := apijson.MarshalRoot(data)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error marshalling resource data",
			fmt.Sprintf("Could not marshal resource data to JSON: %s", err.Error()),
		)
		return
	}

	// Parse the JSON back to interface{} for the generic create
	var resourceData interface{}
	if err := json.Unmarshal(apiData, &resourceData); err != nil {
		resp.Diagnostics.AddError(
			"Error processing resource data",
			fmt.Sprintf("Could not process resource data: %s", err.Error()),
		)
		return
	}

	tflog.Info(ctx, fmt.Sprintf("Creating host: %s", string(apiData)))

	// Create the resource using generic CRUD
	createResp, err := request.CreateResource(r.config, resourceData)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error creating host",
			fmt.Sprintf("Could not create host: %s", err.Error()),
		)
		return
	}

	// Read the created resource to get full details
	var createdData HostResourceModel
	readResp, err := request.ReadResourceByHref(r.config, createResp.Location)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error reading created host",
			fmt.Sprintf("Could not read created host: %s", err.Error()),
		)
		return
	}

    tflog.Debug(ctx, fmt.Sprintf("Reading Host after create: +%v", readResp.Body))

	// Unmarshal the response into our model
	if err := apijson.UnmarshalRoot(readResp.Body, &createdData); err != nil {
		resp.Diagnostics.AddError(
			"Error parsing created host",
			fmt.Sprintf("Could not parse created host: %s", err.Error()),
		)
		return
	}

	CopyReadOnlyHost(ctx, &createdData, &data)

    data.ID = types.StringValue(createResp.Location)
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)

	tflog.Debug(ctx, "Created host successfully")
}
// Read refreshes the Terraform state with the latest data.
func (r *HostResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {

	tflog.Info(ctx, "Beginning Read of host")

}

// Delete removes the Host resource from Terraform state and deletes it from the API.
func (r *HostResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	if r.client == nil {
		resp.Diagnostics.AddError(
			"Unconfigured SMC Client",
			"Expected configured SMC client. Please report this issue to the provider developers.",
		)
		return
	}

	var data HostResourceModel

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Extract resource name for deletion
	var resourceName string
	
	if !data.Name.IsNull() {
		resourceName = data.Name.ValueString()
	}

	if resourceName == "" {
		resp.Diagnostics.AddError(
			"Missing Resource Name",
			"No resource name found to delete host",
		)
		return
	}

	tflog.Info(ctx, fmt.Sprintf("Deleting host '%s'", resourceName))

	// Delete the resource using generic CRUD
	err := request.DeleteResource(r.config, resourceName)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error deleting host",
			fmt.Sprintf("Could not delete host '%s': %s", resourceName, err.Error()),
		)
		return
	}

	tflog.Debug(ctx, fmt.Sprintf("Deleted host '%s' successfully", resourceName))
}

// Update modifies the Host resource and updates the Terraform state on success.
func (r *HostResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	if r.client == nil {
		resp.Diagnostics.AddError(
			"Unconfigured SMC Client",
			"Expected configured SMC client. Please report this issue to the provider developers.",
		)
		return
	}

	var data HostResourceModel
	var stateData HostResourceModel

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Read current state data to preserve readonly fields
	resp.Diagnostics.Append(req.State.Get(ctx, &stateData)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Merge readonly fields from state into plan data
	            data.AdminDomain = stateData.AdminDomain
	            data.Etag = stateData.Etag
	            data.Key = stateData.Key
	            data.Link = stateData.Link
	            data.Locked = stateData.Locked
	            data.ReadOnly = stateData.ReadOnly
	            data.System = stateData.System
	            data.SystemKey = stateData.SystemKey
	            data.Trashed = stateData.Trashed

	// Extract resource name for update
	var resourceName string
	
	if !data.Name.IsNull() {
		resourceName = data.Name.ValueString()
	}

	if resourceName == "" {
		resp.Diagnostics.AddError(
			"Missing Resource Name",
			"No resource name found to update host",
		)
		return
	}

	// Convert Terraform model to API model
	apiData, err := apijson.MarshalRoot(data)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error marshalling resource data",
			fmt.Sprintf("Could not marshal resource data to JSON: %s", err.Error()),
		)
		return
	}

	// Parse the JSON back to interface{} for the generic update
	var resourceData interface{}
	if err := json.Unmarshal(apiData, &resourceData); err != nil {
		resp.Diagnostics.AddError(
			"Error processing resource data",
			fmt.Sprintf("Could not process resource data: %s", err.Error()),
		)
		return
	}

	tflog.Info(ctx, fmt.Sprintf("Updating host '%s': %s", resourceName, string(apiData)))

	// Update the resource using generic CRUD
	updateResp, err := request.UpdateResource(r.config, resourceData, resourceName)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error updating host",
			fmt.Sprintf("Could not update host '%s': %s", resourceName, err.Error()),
		)
		return
	}

	// Read the updated resource to get full details
	var updatedData HostResourceModel
	if updateResp.Location != "" {
		readResp, err := request.ReadResourceByHref(r.config, updateResp.Location)
		if err != nil {
			resp.Diagnostics.AddError(
				"Error reading updated host",
				fmt.Sprintf("Could not read updated host: %s", err.Error()),
			)
			return
		}

		// Initialize any List fields before unmarshaling to avoid type conversion issues
		
		// Unmarshal the response into our model
		if err := apijson.UnmarshalRoot(readResp.Body, &updatedData); err != nil {
			resp.Diagnostics.AddError(
				"Error parsing updated host",
				fmt.Sprintf("Could not parse updated host: %s", err.Error()),
			)
			return
		}

		// Ensure ID is preserved
		if updatedData.ID.IsNull() || updatedData.ID.ValueString() == "" {
			updatedData.ID = data.ID
		}
	} else {
		// Fallback: read by name
		readResp, err := request.ReadResourceByName(r.config, resourceName)
		if err != nil {
			resp.Diagnostics.AddError(
				"Error reading updated host",
				fmt.Sprintf("Could not read updated host: %s", err.Error()),
			)
			return
		}

		// Initialize any List fields before unmarshaling to avoid type conversion issues
		
		// Unmarshal the response into our model
		if err := apijson.UnmarshalRoot(readResp.Body, &updatedData); err != nil {
			resp.Diagnostics.AddError(
				"Error parsing updated host",
				fmt.Sprintf("Could not parse updated host: %s", err.Error()),
			)
			return
		}

		// Ensure ID is preserved
		if updatedData.ID.IsNull() || updatedData.ID.ValueString() == "" {
			updatedData.ID = data.ID
		}
	}

	tflog.Debug(ctx, fmt.Sprintf("Updated host '%s' successfully", resourceName))
	resp.Diagnostics.Append(resp.State.Set(ctx, &updatedData)...)
}
// ImportState imports a Host resource into Terraform state.
func (r *HostResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	id := req.ID
	// If the ID looks like a URL, use it directly
	if strings.HasPrefix(id, "http") {
		resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), id)...) 
		return
	}

	// Otherwise, look up by name and type
	config := r.config
	// Set the resource type for lookup (customize if needed)
	config.ResourceType = "Host" // or hardcode if always 'host'
	readResp, err := request.ReadResourceByName(config, id)
	if err != nil {
		resp.Diagnostics.AddError(
			"Import failed",
			fmt.Sprintf("Could not find Host with name '%s': %s", id, err.Error()),
		)
		return
	}
	if readResp == nil || readResp.Location == "" {
		resp.Diagnostics.AddError(
			"Import failed",
			fmt.Sprintf("No Host found with name '%s'", id),
		)
		return
	}
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), readResp.Location)...) 
}
