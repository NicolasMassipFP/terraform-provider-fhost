#!/bin/bash
# Generic script to run Go commands inside the CI Docker container

set -e

IMAGE=go-docker

# Ensure .cache directories exist for golangci-lint, go build, go mod, and gopath
mkdir -p .cache .cache/go-build .cache/gomod .cache/gopath .cache/uv

# Run the provided command inside the container, preserving user rights and using writable caches
CMD=("$@")
docker run --rm -u $(id -u):$(id -g) \
    -v "$(pwd)":/app -w /app \
    -v "$(pwd)/.cache":/app/.cache \
    -v "$(pwd)/.cache/go-build":/app/.cache/go-build \
    -v "$(pwd)/.cache/gomod":/app/.cache/gomod \
    -v "$(pwd)/.cache/gopath":/app/.cache/gopath \
    -v "$(pwd)/.cache/uv":/app/.cache/uv \
    -e GOLANGCI_LINT_CACHE=/app/.cache \
    -e GOCACHE=/app/.cache/go-build \
    -e GOMODCACHE=/app/.cache/gomod \
    -e GOPATH=/app/.cache/gopath \
    -e UV_CACHE_DIR=/app/.cache/uv \
    -e GPG_FINGERPRINT="${GPG_FINGERPRINT:-}" \
    -e GITHUB_TOKEN="${GITHUB_TOKEN:-}" \
    $IMAGE "${CMD[@]}"

# Ensure proper permissions on gomod cache files (which are often set read-only by Go)
if [ -d ".cache/gomod" ]; then
  find .cache/gomod -type d -exec chmod u+wx {} \;
  find .cache/gomod -type f -exec chmod u+w {} \;
fi
